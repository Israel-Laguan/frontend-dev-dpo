[
 {
  "instruction": "I'm developing a PWA and trying to register a service worker, but it's not working as expected. I have a React app created with Create React App, and I've placed my `sw.js` file in the `public` directory. Here's the simplified registration logic within a React component:\n\n```javascript\nimport React, { useEffect } from 'react';\n\nexport const App = () => {\n  useEffect(() => {\n    if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.register('./sw.js')\n        .then(registration => {\n          console.log('Service Worker registered with scope:', registration.scope);\n        })\n        .catch(error => {\n          console.error('Service Worker registration failed:', error);\n        });\n    }\n  }, []);\n\n  return (\n    <div>My App</div>\n  );\n};\n\n```\n\nI'm testing on `http://localhost:3000`. The service worker file seems to be served correctly (I can access it directly in the browser), but the registration still fails.  What am I doing wrong, and how can I fix it?",
  "files": [
   {
    "path": "src/components/App.tsx",
    "content": "```typescript\nimport React, { useEffect } from 'react';\n\nexport const App: React.FC = () => {\n  useEffect(() => {\n    const registerServiceWorker = async () => {\n      if ('serviceWorker' in navigator) {\n        try {\n          const registration = await navigator.serviceWorker.register('./sw.js');\n          console.log('Service Worker registered with scope:', registration.scope);\n        } catch (error) {\n          console.error('Service Worker registration failed:', error);\n        }\n      }\n    };\n\n    registerServiceWorker();\n  }, []);\n\n  return (\n    <div>My App</div>\n  );\n};\n```"
   },
   {
    "path": "public/sw.js",
    "content": "```javascript\nself.addEventListener('install', (event) => {\n  console.log('Service worker installed');\n});\n\nself.addEventListener('activate', (event) => {\n  console.log('Service worker activated');\n});\n\nself.addEventListener('fetch', (event) => {\n  console.log('Fetch event:', event.request.url);\n});\n```"
   }
  ],
  "packages": "```json\n{\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\"\n  }\n}\n```",
  "bug_type": [
   "Service Worker Registration",
   "Incorrect Path"
  ],
  "failure_symptoms": [
   "Service worker not registering",
   "Error in console during registration"
  ],
  "test": "```typescript\nimport { render, screen } from '@testing-library/react';\nimport { App } from './App';\n\ndescribe('App', () => {\n  it('should register the service worker', async () => {\n    const mockRegister = jest.spyOn(navigator.serviceWorker, 'register');\n    mockRegister.mockImplementation(() => Promise.resolve({ scope: '/' }));\n\n    render(<App />);  \n    expect(mockRegister).toHaveBeenCalledWith('./sw.js');\n  });\n});\n```",
  "rejected": "```typescript\nimport React, { useEffect } from 'react';\n\nexport const App = () => {\n  useEffect(() => {\n    if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.register('/sw.js') // Incorrect path - should still be relative\n        .then(registration => { /* ... */ })\n        .catch(error => { /* ... */ });\n    }\n  }, []);\n\n  // ...\n};\n```",
  "rejected_diff": "```diff\n--- a/src/components/App.tsx\n+++ b/src/components/App.tsx\n@@ -4,7 +4,7 @@\n   useEffect(() => {\n     if ('serviceWorker' in navigator) {\n       navigator.serviceWorker.register(\n-        './sw.js'\n+        '/sw.js'\n       )\n       .then(registration => {\n```",
  "discussion": "The primary issue stems from the incorrect relative path provided to `navigator.serviceWorker.register()`. In a Create React App project, the `public` directory serves as the root for static assets.  Therefore, when referencing files within `public` from your JavaScript code, you must use a relative path starting with `./`.  Using an absolute path like `/sw.js` causes the browser to look for the service worker at the server's root, not within your application's public directory.",
  "chosen": "```typescript\nimport React, { useEffect } from 'react';\n\nexport const App: React.FC = () => {\n  useEffect(() => {\n    const registerServiceWorker = async () => {\n      if ('serviceWorker' in navigator) {\n        try {\n          const registration = await navigator.serviceWorker.register('./sw.js');\n          console.log('Service Worker registered with scope:', registration.scope);\n        } catch (error) {\n          console.error('Service Worker registration failed:', error);\n        }\n      }\n    };\n\n    registerServiceWorker();\n  }, []);\n\n  return (\n    <div>My App</div>\n  );\n};\n\n```",
  "chosen_diff": "```diff\n--- a/src/components/App.tsx\n+++ b/src/components/App.tsx\n@@ -3,13 +3,17 @@\nexport const App: React.FC = () => {\n   useEffect(() => {\n-    if ('serviceWorker' in navigator) {\n-      navigator.serviceWorker.register('./sw.js')\n-        .then(registration => {\n-          console.log('Service Worker registered with scope:', registration.scope);\n-        })\n-        .catch(error => {\n-          console.error('Service Worker registration failed:', error);\n-        });\n+    const registerServiceWorker = async () => {\n+      if ('serviceWorker' in navigator) {\n+        try {\n+          const registration = await navigator.serviceWorker.register('./sw.js');\n+          console.log('Service Worker registered with scope:', registration.scope);\n+        } catch (error) {\n+          console.error('Service Worker registration failed:', error);\n+        }\n+      }\n     }\n+\n+    registerServiceWorker();\n   }, []);\n```"
 },
 {
  "instruction": "I'm working on a dashboard component in React that fetches and displays real-time metrics.  I'm trying to update the component's state with new data from an API call, but the UI isn't reflecting the changes correctly.  Specifically, when I click the \"Refresh Metrics\" button, which triggers the API call and subsequent state update using `setMetricsData`, the component re-renders, but the displayed metrics don't change. I'm pretty sure the API call is working and returning the correct data, so I suspect the issue lies somewhere in my state update logic within the `refreshMetrics` function. Could you help me diagnose and fix this? \n\nHere's a simplified version of my component:\n\n```jsx\nimport React, { useState, useEffect } from 'react';\nimport { fetchMetrics } from './api';\n\nfunction MetricsDashboard() {\n  const [metricsData, setMetricsData] = useState([]);\n\n  useEffect(() => {\n    refreshMetrics();\n  }, []);\n\n  const refreshMetrics = async () => {\n    const newMetrics = await fetchMetrics();\n    setMetricsData(newMetrics);\n    console.log('Metrics updated:', newMetrics); // This shows the correct data\n  };\n\n  return (\n    <div>\n      <button onClick={refreshMetrics}>Refresh Metrics</button>\n      <ul>\n        {metricsData.map((metric) => (\n          <li key={metric.id}>{metric.name}: {metric.value}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```",
  "files": [
   {
    "path": "components/MetricsDashboard.tsx",
    "content": "```tsx\nimport React, { useState, useEffect } from 'react';\nimport { fetchMetrics } from '../api/metrics';\n\ninterface Metric {\n  id: string;\n  name: string;\n  value: number;\n}\n\nconst MetricsDashboard: React.FC = () => {\n  const [metricsData, setMetricsData] = useState<Metric[]>([]);\n\n  useEffect(() => {\n    refreshMetrics();\n  }, []);\n\n  const refreshMetrics = async () => {\n    const newMetrics = await fetchMetrics();\n    setMetricsData(newMetrics);\n  };\n\n  return (\n    <div>\n      <button onClick={refreshMetrics}>Refresh Metrics</button>\n      <ul>\n        {metricsData.map((metric) => (\n          <li key={metric.id}>{metric.name}: {metric.value}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default MetricsDashboard;\n```"
   },
   {
    "path": "api/metrics.ts",
    "content": "```typescript\nimport { Metric } from '../types/metrics';\n\nexport const fetchMetrics = async (): Promise<Metric[]> => {\n  // Simulated API call\n  await new Promise(resolve => setTimeout(resolve, 500)); \n  return [\n    { id: '1', name: 'CPU Usage', value: Math.random() * 100 },\n    { id: '2', name: 'Memory Usage', value: Math.random() * 100 },\n    { id: '3', name: 'Network Traffic', value: Math.random() * 100 },\n  ];\n};\n```"
   },
   {
    "path": "types/metrics.ts",
    "content": "```typescript\nexport interface Metric {\n  id: string;\n  name: string;\n  value: number;\n}\n```"
   }
  ],
  "packages": "```\n{\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"@testing-library/react\": \"^14.0.0\"\n  }\n}\n```",
  "bug_type": [
   "Stale Closure"
  ],
  "failure_symptoms": [
   "UI not updating after state update"
  ],
  "test": "```tsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport MetricsDashboard from '../components/MetricsDashboard';\n\njest.mock('../api/metrics', () => ({\n  fetchMetrics: jest.fn(() => Promise.resolve([\n    { id: '1', name: 'CPU Usage', value: 75 },\n    { id: '2', name: 'Memory Usage', value: 50 },\n  ])), \n}));\n\ndescribe('MetricsDashboard', () => {\n  it('updates the metrics on button click', async () => {\n    render(<MetricsDashboard />);\n    fireEvent.click(screen.getByText('Refresh Metrics'));\n    await screen.findByText('CPU Usage: 75');\n    await screen.findByText('Memory Usage: 50');\n  });\n});\n```",
  "rejected": "```tsx\n// This solution attempts to force a re-render by adding a dummy state variable,\n// but it's inefficient and doesn't address the root cause of the stale closure.\nimport React, { useState, useEffect } from 'react';\nimport { fetchMetrics } from './api';\n\nfunction MetricsDashboard() {\n  const [metricsData, setMetricsData] = useState([]);\n  const [dummyState, setDummyState] = useState(false); // Added dummy state\n\n  useEffect(() => {\n    refreshMetrics();\n  }, []);\n\n  const refreshMetrics = async () => {\n    const newMetrics = await fetchMetrics();\n    setMetricsData(newMetrics);\n    setDummyState(!dummyState); // Toggle dummy state to force re-render\n  };\n\n  // ... rest of the component code\n}\n```",
  "rejected_diff": "```diff\n--- a/components/MetricsDashboard.tsx\n+++ b/components/MetricsDashboard.tsx\n@@ -4,6 +4,7 @@\n \n function MetricsDashboard() {\n   const [metricsData, setMetricsData] = useState([]);\n+  const [dummyState, setDummyState] = useState(false);\n \n   useEffect(() => {\n     refreshMetrics();\n@@ -13,6 +14,7 @@\n   const refreshMetrics = async () => {\n     const newMetrics = await fetchMetrics();\n     setMetricsData(newMetrics);\n+    setDummyState(!dummyState);\n   };\n \n   return (\n\n```",
  "discussion": "The issue stems from the `refreshMetrics` function relying on the `metricsData` state from its initial render. This creates a stale closure. Each time `refreshMetrics` is called, it captures the initial `metricsData` value (an empty array). Therefore, even though the `setMetricsData` call updates the state, the `metricsData` variable inside `refreshMetrics` remains outdated.\n\nTo solve this, we should use a functional form of `setMetricsData`:",
  "chosen": "```tsx\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { fetchMetrics } from '../api/metrics';\nimport { Metric } from '../types/metrics';\n\nconst MetricsDashboard: React.FC = () => {\n  const [metricsData, setMetricsData] = useState<Metric[]>([]);\n\n  const refreshMetrics = useCallback(async () => {\n    const newMetrics = await fetchMetrics();\n    setMetricsData(prevMetrics => newMetrics); // Functional update\n  }, []);\n\n  useEffect(() => {\n    refreshMetrics();\n  }, [refreshMetrics]);\n\n  return (\n    <div>\n      <button onClick={refreshMetrics}>Refresh Metrics</button>\n      <ul>\n        {metricsData.map((metric) => (\n          <li key={metric.id}>{metric.name}: {metric.value}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default MetricsDashboard;\n```",
  "chosen_diff": "```diff\n--- a/components/MetricsDashboard.tsx\n+++ b/components/MetricsDashboard.tsx\n@@ -1,4 +1,4 @@\n-import React, { useState, useEffect } from 'react';\n+import React, { useState, useEffect, useCallback } from 'react';\n import { fetchMetrics } from '../api/metrics';\n \n function MetricsDashboard() {\n@@ -9,10 +9,12 @@\n     refreshMetrics();\n   }, []);\n \n-  const refreshMetrics = async () => {\n+  const refreshMetrics = useCallback(async () => {\n     const newMetrics = await fetchMetrics();\n-    setMetricsData(newMetrics);\n+    setMetricsData(prevMetrics => newMetrics);\n   };\n+\n+  // Add refreshMetrics to the dependency array to prevent stale closures\n+}, [refreshMetrics]);\n \n   return (\n     <div>\n\n```"
 },
 {
  "instruction": "I'm working on a React project and I'm trying to use a custom font. I've placed the `Metropolis-Regular.woff2` font file in a `fonts` directory at the root of my project. I've added the `@font-face` rule in my global styles file (`styles/global.css`), and I'm applying the font to a specific component's title (`<Typography variant=\"h1\">`). However, the font isn't being applied.  I've double-checked the file path, and it seems correct. What could be the issue?\n\nHere's a simplified version of my code:\n\n```typescript jsx\n// components/MyComponent.tsx\nimport React from 'react';\nimport { Typography } from '@mui/material';\nimport '../styles/global.css';\n\nconst MyComponent: React.FC = () => {\n  return (\n    <Typography variant=\"h1\" className=\"custom-font\">\n      My Custom Font Title\n    </Typography>\n  );\n};\n\nexport default MyComponent;\n```\n\n```css\n/* styles/global.css */\n@font-face {\n  font-family: 'Metropolis';\n  src: url('../fonts/Metropolis-Regular.woff2') format('woff2');\n  font-weight: normal;\n  font-style: normal;\n}\n\n.custom-font {\n  font-family: 'Metropolis', sans-serif;\n}\n```",
  "files": [
   {
    "path": "components/MyComponent.tsx",
    "content": "```typescript jsx\nimport React from 'react';\nimport { Typography } from '@mui/material';\nimport '../styles/global.css';\n\nconst MyComponent: React.FC = () => {\n  return (\n    <Typography variant=\"h1\" className=\"custom-font\">\n      My Custom Font Title\n    </Typography>\n  );\n};\n\nexport default MyComponent;\n```"
   },
   {
    "path": "styles/global.css",
    "content": "```css\n@font-face {\n  font-family: 'Metropolis';\n  src: url('../fonts/Metropolis-Regular.woff2') format('woff2');\n  font-weight: normal;\n  font-style: normal;\n  font-display: swap; /* Added for better rendering performance */\n}\n\n.custom-font {\n  font-family: 'Metropolis', sans-serif;\n}\n```"
   },
   {
    "path": "public/index.html",
    "content": "```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <link rel=\"preload\" href=\"%PUBLIC_URL%/fonts/Metropolis-Regular.woff2\" as=\"font\" type=\"font/woff2\" crossorigin />\n  {/* ... other head elements ... */}\n</head>\n<body>\n  <div id=\"root\"></div>\n</body>\n</html>\n```"
   }
  ],
  "packages": "```json\n{\n  \"dependencies\": {\n    \"@mui/material\": \"^5.11.15\",\n    \"react\": \"^18.2.0\"\n  }\n}\n```",
  "bug_type": [
   "CSS",
   "Font Loading",
   "React Component Styling"
  ],
  "failure_symptoms": [
   "Custom font not applied",
   "Default browser font displayed"
  ],
  "test": "```typescript jsx\nimport { render, screen } from '@testing-library/react';\nimport MyComponent from '../components/MyComponent';\n\njest.mock('../styles/global.css', () => jest.fn()); // Mock CSS import\n\n// Mock the font file\njest.mock('../fonts/Metropolis-Regular.woff2', () => '', { virtual: true });\n\ndescribe('MyComponent', () => {\n  it('should apply the custom font to the title', async () => {\n    render(<MyComponent />);\n    const titleElement = screen.getByRole('heading', { level: 1 });\n    // Assert that the font-family is applied (this will depend on your testing setup and how you handle CSS-in-JS)\n    expect(window.getComputedStyle(titleElement).fontFamily).toBe('Metropolis'); \n  });\n});\n```",
  "rejected": "```typescript jsx\n// components/MyComponent.tsx\nimport React from 'react';\nimport { Typography } from '@mui/material';\nimport '../styles/global.css';\n\nconst MyComponent: React.FC = () => {\n  return (\n    <Typography variant=\"h1\" style={{ fontFamily: 'Metropolis' }}>\n      My Custom Font Title\n    </Typography>\n  );\n};\n\nexport default MyComponent;\n```",
  "rejected_diff": "```diff\n--- a/components/MyComponent.tsx\n+++ b/components/MyComponent.tsx\n@@ -5,7 +5,7 @@\n const MyComponent: React.FC = () => {\n   return (\n-    <Typography variant=\"h1\" className=\"custom-font\">\n+    <Typography variant=\"h1\" style={{ fontFamily: 'Metropolis' }}>\n       My Custom Font Title\n     </Typography>\n   );\n```",
  "discussion": "The issue is likely due to how the font file is loaded and how CSS is applied in your project. Inline styles override external styles, which may be why the previous fix with `style` seemed to work. \n\nThe `@font-face` rule is correctly placed in the global styles, which is the correct approach. However, there could be problems with the font file itself.  The path in `url('../fonts/Metropolis-Regular.woff2')` is relative to the CSS file, not the component or the project root. Double-check that this path is correct and ensure the font loads successfully. Preloading fonts and ensuring font-display is set appropriately further improves reliability and performance.  The provided solution leverages `%PUBLIC_URL%` in `index.html` to correctly resolve the font path and preloads the font for optimized loading.",
  "chosen": "```typescript jsx\n// components/MyComponent.tsx\nimport React from 'react';\nimport { Typography } from '@mui/material';\nimport '../styles/global.css';\n\nconst MyComponent: React.FC = () => {\n  return (\n    <Typography variant=\"h1\" className=\"custom-font\">\n      My Custom Font Title\n    </Typography>\n  );\n};\n\nexport default MyComponent;\n```\n\n```css\n/* styles/global.css */\n@font-face {\n  font-family: 'Metropolis';\n  src: url('../fonts/Metropolis-Regular.woff2') format('woff2');\n  font-weight: normal;\n  font-style: normal;\n  font-display: swap; /* Added for better rendering performance */\n}\n\n.custom-font {\n  font-family: 'Metropolis', sans-serif;\n}\n```\n\n```html\n{/* public/index.html */}\n<link rel=\"preload\" href=\"%PUBLIC_URL%/fonts/Metropolis-Regular.woff2\" as=\"font\" type=\"font/woff2\" crossorigin />\n```",
  "chosen_diff": "```diff\n--- a/styles/global.css\n+++ b/styles/global.css\n@@ -4,6 +4,7 @@\n   src: url('../fonts/Metropolis-Regular.woff2') format('woff2');\n   font-weight: normal;\n   font-style: normal;\n+  font-display: swap;\n }\n \n .custom-font {\n\n--- a/public/index.html\n+++ b/public/index.html\n@@ -3,6 +3,7 @@\n <html lang=\"en\">\n <head>\n   <meta charset=\"utf-8\" />\n+  <link rel=\"preload\" href=\"%PUBLIC_URL%/fonts/Metropolis-Regular.woff2\" as=\"font\" type=\"font/woff2\" crossorigin />\n   {/* ... other head elements ... */}\n </head>\n <body>\n```"
 }
]